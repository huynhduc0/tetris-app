node_modules/**/*
.expo/*
npm-debug.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision
*.orig.*
web-build/
web-report/

# macOS
.DS_Store

import React from 'react';
import { StyleSheet, Text, View, Dimensions, Button } from 'react-native';
import Canvas from 'react-native-canvas';
const SCREEN_HEIGHT = Dimensions.get('window').height;
const SCREEN_WIDTH = Dimensions.get('window').width;

export default function App() {
	createMatrix = (w, h) => {
		const matrix = [];
		while (h--) {
			matrix.push(new Array(w).fill(0));
		}
		return matrix;
	};

	this.state = {
		matrix: null,
		arena: this.createMatrix(12, 20),
		canvas: null,
		name:"THDUC",
		player: {
			pos: { x: 0, y: 0 },
			matrix: null,
			score: 0,
		},
		context: null,
	};
	context = null;

	const { arena, player } = this.state;
	const colors = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'];
	const ws= null;
	emit = (data) =>{
		const msg = JSON.stringify(data);
		console.log(`message sending: ${msg}..`);
		this.ws.send(msg);
	}
	
	stateEmit = (fragement,key) =>{
		let ahihi = (fragement=="player")?player:arena;
		let	dt  = {type:"state-update",fragement:fragement,state:[key,player.matrix]};
		const msg = JSON.stringify(dt);
		console.log(`message sending: ${msg}..`);
		this.ws.send(msg);
	}
	
	drawMatrix = (matrix, offset) => {
		this.context.fillStyle = '#00F';
		matrix.forEach((row, y) => {
			row.forEach((value, x) => {
				if (value !== 0) {
					this.context.fillStyle = colors[value];
					this.context.fillRect(x + offset.x, y + offset.y, 1, 1);
				}
			});
		});
	};

	merge = (arena, player) => {
		player.matrix.forEach((row, y) => {
			row.forEach((value, x) => {
				if (value !== 0) {
					arena[y + player.pos.y][x + player.pos.x] = value;
				}
			});
		});
		this.stateEmit('arena','player','maxtrix');
	};
	rotate = (matrix, dir) => {
		for (let y = 0; y < matrix.length; ++y) {
			for (let x = 0; x < y; ++x) {
				[matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
			}
		}

		if (dir > 0) {
			matrix.forEach(row => row.reverse());
		} else {
			matrix.reverse();
		}
		this.stateEmit('player','maxtrix',player);
	};
	createPiece = type => {
		if (type === 'I') {
			return [
				[0, 1, 0, 0],
				[0, 1, 0, 0],
				[0, 1, 0, 0],
				[0, 1, 0, 0],
			];
		} else if (type === 'L') {
			return [
				[0, 2, 0],
				[0, 2, 0],
				[0, 2, 2],
			];
		} else if (type === 'J') {
			return [
				[0, 3, 0],
				[0, 3, 0],
				[3, 3, 0],
			];
		} else if (type === 'O') {
			return [
				[4, 4],
				[4, 4],
			];
		} else if (type === 'Z') {
			return [
				[5, 5, 0],
				[0, 5, 5],
				[0, 0, 0],
			];
		} else if (type === 'S') {
			return [
				[0, 6, 6],
				[6, 6, 0],
				[0, 0, 0],
			];
		} else if (type === 'T') {
			return [
				[0, 7, 0],
				[7, 7, 7],
				[0, 0, 0],
			];
		}
	};

	arenaSweep = () => {
		let rowCount = 1;
		outer: for (let y = arena.length - 1; y > 0; --y) {
			for (let x = 0; x < arena[y].length; ++x) {
				if (arena[y][x] === 0) {
					continue outer;
				}
			}

			const row = arena.splice(y, 1)[0].fill(0);
			arena.unshift(row);
			++y;

			player.score += rowCount * 10;
			rowCount *= 2;
			this.stateEmit('arena','maxtrix');
		}
	};
	collide = (arena, player) => {
		const m = player.matrix;
		const o = player.pos;
		for (let y = 0; y < m.length; ++y) {
			for (let x = 0; x < m[y].length; ++x) {
				if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
					return true;
				}
			}
		}
		return false;
	};

	 playerDrop = ()=> {
		player.pos.y++;
		if (collide(arena, player)) {
			player.pos.y--;
			merge(arena, player);
			playerReset();
			arenaSweep();
			//  updateScore();
		}
		dropCounter = 0;
  }
  _onPressButton =()=> {
    alert('You tapped the button!')
  }

	playerMove = (offset) => {
		player.pos.x += offset;
		if (collide(arena, player)) {
			player.pos.x -= offset;
		}
	}
	playerReset = () => {
		const pieces = 'TJLOSZI';
		let index = Math.floor(Math.random() * pieces.length - 1) + 1;
		//  alert(index)
		player.matrix = this.createPiece(pieces[index]);

		// alert(pieces.length * Math.random());
		player.pos.y = 0;
		player.pos.x = ((arena[0].length / 2) | 0) - ((player.matrix[0].length / 2) | 0);
		if (this.collide(arena, player)) {
			arena.forEach(row => row.fill(0));
			player.score = 0;
			//updateScore();
		}
		this.stateEmit('arena','maxtrix');
		this.stateEmit('player','maxtrix');
	};
	 playerRotate = (dir)=> {
		const pos = player.pos.x;
		let offset = 1;
		this.rotate(player.matrix, dir);
		while (this.collide(arena, player)) {
			player.pos.x += offset;
			offset = -(offset + (offset > 0 ? 1 : -1));
			if (offset > player.matrix[0].length) {
				this.rotate(player.matrix, -dir);
				player.pos.x = pos;
				return;
			}
		}
	}
	let dropCounter = 0;
	let dropInterval = 1000;

	let lastTime = 0;
	update = (time = 0) => {
		const deltaTime = time - lastTime;

		dropCounter += deltaTime;
		if (dropCounter > dropInterval) {
			playerDrop();
		}

		lastTime = time;
		this.draw();
		requestAnimationFrame(this.update);
	};
	draw = () => {
		// this.context = canvas.getContext('2d');
		this.context.fillStyle = '#000';
		this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
		drawMatrix(arena, { x: 0, y: 0 });
		drawMatrix(player.matrix, player.pos);
	};
